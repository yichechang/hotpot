configfile: workflow.source_path('./config.yaml')

wildcard_constraints:
    sample = "[\w-]+",
    binsize = "\d+",


def get_all_sample_something(something):
    samples = config["samples"]
    return [s[something] for s in samples]

def get_all_sample_something_by_name(something, names):
    samples = config["samples"]
    somethings = []
    for n in names:
        for s in samples:
            if s["name"] == n:
                somethings.append(s[something])
                break
    return somethings

SAMPLE_NAMES = get_all_sample_something("name")
SAMPLE_DESC = get_all_sample_something_by_name("desc", SAMPLE_NAMES)

#
# This can be used inside an input function, to get {AluName}.
#
def get_checkpoint_aluname(wildcards):
    checkpoints.split_alu_bedfile.get(**wildcards)
    return glob_wildcards("results/alu_bed_split/{AluName, [\w-]+}.bed").AluName


#
# top-level target rules
#
rule all_split_alu:
    input:
        lambda w: expand("results/alu_bed_split/{alu_name}.bed",
                         alu_name=get_checkpoint_aluname(w))

rule all_bigwig:
    input:
        lambda w: expand("results/bigwig/{sample}_{binsize}bp.bw",
                         sample=SAMPLE_NAMES,
                         binsize=config['bam_to_bigwig']['binsizes'])

rule all_matrix:
    input:
        lambda w: expand("results/matrix/{alu_name}_{binsize}bp.gz", 
                         alu_name=get_checkpoint_aluname(w),
                         binsize=config['bam_to_bigwig']['binsizes'])

rule all_heatmaps:
    input:
        lambda w: expand("results/heatmap/{alu_name}_{binsize}bp.{ext}",
                         alu_name=get_checkpoint_aluname(w),
                         binsize=config['bam_to_bigwig']['binsizes'],
                         ext=["pdf", "gz"])

rule all_profiles:
    input:
        lambda w: expand("results/profile/{alu_name}_{binsize}bp.{ext}",
                         alu_name=get_checkpoint_aluname(w),
                         binsize=config['bam_to_bigwig']['binsizes'],
                         ext=["pdf", "tab"])

rule all_alu_bw:
    input:
        lambda w: expand("results/alu_bigwig_split/{alu_name}.bw",
                         alu_name=get_checkpoint_aluname(w))

rule all:
    input:
        rules.all_profiles.input,
        rules.all_heatmaps.input,

rule all_envs:
    """
    Run this rule with internect access. This is a workaround for creating
    conda environments associated with rules that are not discoverable 
    until runtime (e.g., rules downstream to checkpoint rules).
    """
    input:
        expand(".envs/{env}.created",
               env=glob_wildcards("envs/{env, [\w-]+}.yaml").env)

rule make_env:
    conda:
        "envs/{env}.yaml"
    output:
        touch(".envs/{env}.created")
    shell:
        """
        sleep .5
        """

#
# actual workhorse rules
#

# Make sure Alu names appear in column 2
# Produces a text file like:
# """
# >DF0000002.4 AluY
# >DF0000003.4 AluSc
# >DF0000007.4 AluJb
# """
rule list_alu_names:
    input:
        config['alu_families_fasta'],
    output:
        "results/alu_names.txt"
    shell:
        """
        awk '/^>/{{print}}' {input:q} > {output}
        """

rule alu_bedfile:
    input:
        alu="results/alu_names.txt",
        rmsk=config['rmsk'],
    output:
        bed="results/hg38.alu.repeats.bed"
    run:
        aluList = open(input.alu,"r")
        file = open(input.rmsk,"r")
        fOut = open(output.bed,"w")

        aluFam=[]
        for a in aluList:
            name=a.split("\n")[0].split(" ")[1]
            aluFam.append(name)
        aluList.close()

        for f in file:
            x = f.split("\t")[3]
            if x in aluFam:
                fOut.write(f)
        fOut.close()


rule truncate_alu_bedfile:
    input:
        bed="results/hg38.alu.repeats.bed"
    output:
        bed="results/alu.bed"
    params:
        n=config['alu_annotation_truncation']
    shell:
        """
        if [ {params.n} == 0 ]; then
            cp {input.bed} {output.bed}
        else
            head --lines {params.n} {input.bed:q} > {output.bed}
        fi
        """

checkpoint split_alu_bedfile:
    input:
        bed="results/alu.bed"
    output:
        outdir=directory("results/alu_bed_split"),
        marker=touch("results/alu_bed_split/.done")
    shell:
        """
        awk '{{file = "{output.outdir}/"$4".bed"; print >> file; close(file)}}' {input:q}
        """

def get_mapped_filenames(wildcards):
    return config['bam_dir'] + config['bam_filename_pattern']

rule bam_to_bigwig:
    input:
        bam=get_mapped_filenames
    output:
        bw="results/bigwig/{sample}_{binsize}bp.bw"
    conda: 
        "envs/deeptools.yaml"
    shell:
        """
        bamCoverage -b {input.bam:q} -o {output.bw:q} \
            --binSize {wildcards.binsize} \
            --extendReads
        """

rule compute_matrix:
    input:
        bigwig=expand("results/bigwig/{sample}_{binsize}bp.bw", 
                      sample=SAMPLE_NAMES, allow_missing=True),
        region="results/alu_bed_split/{alu_name}.bed",
    output:
        "results/matrix/{alu_name}_{binsize}bp.gz"
    params:
        before=config["compute_matrix"]["params"]["before"],
        after=config["compute_matrix"]["params"]["after"],
        body=config["compute_matrix"]["params"]["body"],
        samplesLabel=" ".join(SAMPLE_DESC),
    threads:
        config["compute_matrix"]["cores"]
    conda: 
        "envs/deeptools.yaml"
    shell:
        """
        computeMatrix scale-regions \
        --scoreFileName {input.bigwig} \
        --regionsFileName {input.region} \
        --regionBodyLength {params.body} \
        --startLabel start \
        --endLabel end \
        -b {params.before} -a {params.after} \
        --binSize {wildcards.binsize} \
        --skipZeros \
        --samplesLabel {params.samplesLabel} \
        -o {output} \
        -p {threads}
        """


rule plot_heatmap:
    input:
        "results/matrix/{alu_name}_{binsize}bp.gz",
    output:
        plot="results/heatmap/{alu_name}_{binsize}bp.pdf",
        data="results/heatmap/{alu_name}_{binsize}bp.gz",
    conda: 
        "envs/deeptools.yaml"
    shell:
        """
        plotHeatmap \
        -m {input} \
        -out {output.plot} \
        --outFileNameMatrix {output.data} \
        --colorMap cividis \
        --missingDataColor "#FFF6EB" \
        --dpi 300 \
        --heatmapHeight 8 \
        --whatToShow "heatmap only" \
        --boxAroundHeatmaps no \
        --xAxisLabel " " \
        --startLabel "Start" \
        --endLabel "End" \
        --labelRotation 45 \
        --plotTitle {wildcards.alu_name} \
        """


rule plot_profile:
    input:
        "results/matrix/{alu_name}_{binsize}bp.gz",
    output:
        plot="results/profile/{alu_name}_{binsize}bp.pdf",
        data="results/profile/{alu_name}_{binsize}bp.tab",
    conda:
        "envs/deeptools.yaml"
    shell:
        """
        plotProfile \
        -m {input} \
        -out {output.plot} \
        --outFileNameData {output.data} \
        --dpi 300 \
        --plotType lines \
        --startLabel "Start" \
        --endLabel "End" \
        --plotTitle {wildcards.alu_name} \
        --yAxisLabel reads \
        """


# calculate Alu density
rule alu_bedgraph:
    input:
        bed="results/alu_bed_split/{alu_name}.bed",
        genome=config["genome"]["hg38"],
    output:
        "results/alu_bedgraph_split/{alu_name}.bedgraph"
    conda:
        "envs/bedtools.yaml"
    shell:
        """
        bedtools genomecov -bg -i {input.bed} -g {input.genome} > {output}
        """


rule alu_bigwig:
    input:
        alu="results/alu_bedgraph_split/{alu_name}.bedgraph",
        genome=config["genome"]["hg38"],
    output:
        "results/alu_bigwig_split/{alu_name}.bw"
    conda:
        "envs/bedgraphtobigwig.yaml"
    shell:
        """
        bedGraphToBigWig {input.alu} {input.genome} {output}
        """